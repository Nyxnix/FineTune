// FineTune/Audio/ProcessTapController.swift
import AudioToolbox
import Foundation
import os

// MARK: - Threading Model
//
// ProcessTapController bridges two execution domains:
//
// 1. **Main thread / @MainActor**: All setup, teardown, and state management.
//    - activate(), invalidate(), updateDevices(), performCrossfadeSwitch()
//    - Property writes to nonisolated(unsafe) vars (_volume, _isMuted, etc.)
//    - This class is NOT @MainActor itself because the HAL I/O callback is not on main.
//
// 2. **HAL I/O thread (real-time)**: Audio processing callbacks.
//    - processAudio(), processAudioSecondary()
//    - Only reads nonisolated(unsafe) vars — never writes except _peakLevel/_secondaryPeakLevel
//    - MUST NOT allocate, lock, log, or call ObjC. See .claude/rules/rt-safety.md
//
// The nonisolated(unsafe) annotation marks variables that cross the thread boundary.
// Aligned Float32/Bool/Int reads/writes are atomic on Apple ARM64/x86-64.

final class ProcessTapController {
    let app: AudioApp
    private let logger: Logger
    // Note: This queue is passed to AudioDeviceCreateIOProcIDWithBlock but the actual
    // audio callback runs on CoreAudio's real-time HAL I/O thread, not this queue.
    private let queue = DispatchQueue(label: "ProcessTapController", qos: .userInitiated)

    /// Weak reference to device monitor for O(1) device lookups during crossfade
    private weak var deviceMonitor: AudioDeviceMonitor?

    // MARK: - RT-Safe State (nonisolated(unsafe) for lock-free audio thread access)
    //
    // These variables are accessed from CoreAudio's real-time thread without locks.
    // SAFETY: Aligned Float32/Bool reads/writes are atomic on Apple ARM/Intel platforms.
    // The audio callback reads these values; the main thread writes them.
    // No lock is needed because single-word aligned loads/stores are atomic.

    /// Target volume set by user (0.0-2.0, where 1.0 = unity gain, 2.0 = +6dB boost)
    private nonisolated(unsafe) var _volume: Float = 1.0
    /// Current ramped volume for primary tap (smoothly approaches _volume)
    private nonisolated(unsafe) var _primaryCurrentVolume: Float = 1.0
    /// Current ramped volume for secondary tap during crossfade
    private nonisolated(unsafe) var _secondaryCurrentVolume: Float = 1.0
    /// Emergency silence flag - zeroes output immediately (used during destructive device switch)
    /// Unlike _isMuted, this bypasses all processing including VU metering
    private nonisolated(unsafe) var _forceSilence: Bool = false
    /// User-controlled mute - still tracks VU levels but outputs silence
    private nonisolated(unsafe) var _isMuted: Bool = false
    // Device volume compensation removed — was dead code (always 1.0).
    // If implementing, ensure both primary and secondary callbacks disable
    // compensation during crossfade to avoid gain jumps (RT-013).
    /// Smoothed peak level for VU meter display (exponential moving average)
    private nonisolated(unsafe) var _peakLevel: Float = 0.0
    /// Separate peak level for secondary tap during crossfade (avoids torn RMW from concurrent callbacks)
    private nonisolated(unsafe) var _secondaryPeakLevel: Float = 0.0
    private nonisolated(unsafe) var _currentDeviceVolume: Float = 1.0
    private nonisolated(unsafe) var _isDeviceMuted: Bool = false

    /// Crossfade state machine (RT-safe).
    /// During device switch, we run two taps simultaneously with complementary gain curves:
    /// - Primary uses cos(progress * π/2) → fades from 1.0 to 0.0
    /// - Secondary uses sin(progress * π/2) → fades from 0.0 to 1.0
    /// This "equal power" crossfade maintains perceived loudness throughout the transition.
    /// See CrossfadeState for phase machine details.
    private nonisolated(unsafe) var crossfadeState = CrossfadeState()

    // MARK: - Non-RT State (modified only from main thread)

    /// VU meter smoothing factor. 0.3 gives ~30ms attack/decay at typical 30fps UI refresh.
    /// Lower = smoother but slower response; higher = jittery but more responsive.
    private let levelSmoothingFactor: Float = 0.3
    /// Volume ramp coefficient computed as: 1 - exp(-1 / (sampleRate * rampTime))
    /// Default 0.0007 corresponds to ~30ms ramp at 48kHz. Prevents clicks on volume changes.
    private nonisolated(unsafe) var rampCoefficient: Float = 0.0007
    private nonisolated(unsafe) var secondaryRampCoefficient: Float = 0.0007
    private nonisolated(unsafe) var eqProcessor: EQProcessor?

    // Target device UIDs for synchronized multi-output (first is clock source)
    private var targetDeviceUIDs: [String]
    // Current active device UIDs
    private(set) var currentDeviceUIDs: [String] = []

    /// Primary device UID (clock source, first in array) - for backward compatibility
    var currentDeviceUID: String? { currentDeviceUIDs.first }

    // Core Audio resources (primary tap) — TapResources enforces correct teardown order
    private var primaryResources = TapResources()
    private var activated = false

    // Secondary tap for crossfade
    private var secondaryResources = TapResources()

    /// Guard against re-entrant crossfade (ORCH-001)
    private var isSwitching = false
    /// Cancellable crossfade task — cancelled when a new switch starts
    private var crossfadeTask: Task<Void, Error>?

    // MARK: - Public Properties

    var audioLevel: Float { crossfadeState.isActive ? max(_peakLevel, _secondaryPeakLevel) : _peakLevel }

    var currentDeviceVolume: Float {
        get { _currentDeviceVolume }
        set { _currentDeviceVolume = newValue }
    }

    var isDeviceMuted: Bool {
        get { _isDeviceMuted }
        set { _isDeviceMuted = newValue }
    }

    var volume: Float {
        get { _volume }
        set { _volume = newValue }
    }

    var isMuted: Bool {
        get { _isMuted }
        set { _isMuted = newValue }
    }

    // MARK: - Initialization

    /// Initialize with multiple output devices for synchronized multi-device output.
    /// First device in array is the clock source, others have drift compensation enabled.
    init(app: AudioApp, targetDeviceUIDs: [String], deviceMonitor: AudioDeviceMonitor? = nil) {
        precondition(!targetDeviceUIDs.isEmpty, "Must have at least one target device")
        self.app = app
        self.targetDeviceUIDs = targetDeviceUIDs
        self.deviceMonitor = deviceMonitor
        self.logger = Logger(subsystem: Bundle.main.bundleIdentifier ?? "FineTune", category: "ProcessTapController(\(app.name))")
    }

    /// Convenience initializer for single device output.
    convenience init(app: AudioApp, targetDeviceUID: String, deviceMonitor: AudioDeviceMonitor? = nil) {
        self.init(app: app, targetDeviceUIDs: [targetDeviceUID], deviceMonitor: deviceMonitor)
    }

    // MARK: - Public Methods

    func updateEQSettings(_ settings: EQSettings) {
        eqProcessor?.updateSettings(settings)
    }

    // MARK: - Multi-Device Aggregate Configuration

    /// Builds aggregate device description for synchronized multi-device output.
    /// First device is clock source (no drift compensation), others sync to it via drift compensation.
    private func buildAggregateDescription(outputUIDs: [String], tapUUID: UUID, name: String) -> [String: Any] {
        precondition(!outputUIDs.isEmpty, "Must have at least one output device")

        // Build sub-device list - first device is clock source
        var subDevices: [[String: Any]] = []
        for (index, deviceUID) in outputUIDs.enumerated() {
            subDevices.append([
                kAudioSubDeviceUIDKey: deviceUID,
                // First device (index 0) is clock source - no drift compensation needed
                // All other devices have drift compensation enabled to sync to clock
                kAudioSubDeviceDriftCompensationKey: index > 0
            ])
        }

        let clockDeviceUID = outputUIDs[0]  // Primary = clock source

        return [
            kAudioAggregateDeviceNameKey: name,
            kAudioAggregateDeviceUIDKey: UUID().uuidString,
            kAudioAggregateDeviceMainSubDeviceKey: clockDeviceUID,
            kAudioAggregateDeviceClockDeviceKey: clockDeviceUID,
            kAudioAggregateDeviceIsPrivateKey: true,
            kAudioAggregateDeviceIsStackedKey: true,  // All sub-devices receive same audio
            kAudioAggregateDeviceTapAutoStartKey: true,
            kAudioAggregateDeviceSubDeviceListKey: subDevices,
            kAudioAggregateDeviceTapListKey: [
                [
                    kAudioSubTapDriftCompensationKey: true,
                    kAudioSubTapUIDKey: tapUUID.uuidString
                ]
            ]
        ]
    }

    func activate() throws {
        guard !activated else { return }

        logger.debug("Activating tap for \(self.app.name)")

        // Create process tap
        // CATapDescription produces stereo Float32 interleaved audio from the target process.
        // mutedWhenTapped ensures the app's audio goes through our tap, not directly to output.
        let tapDesc = CATapDescription(stereoMixdownOfProcesses: [app.objectID])
        tapDesc.uuid = UUID()
        tapDesc.muteBehavior = .mutedWhenTapped
        primaryResources.tapDescription = tapDesc

        var tapID: AudioObjectID = .unknown
        var err = AudioHardwareCreateProcessTap(tapDesc, &tapID)
        guard err == noErr else {
            throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: [NSLocalizedDescriptionKey: "Failed to create process tap: \(err)"])
        }

        primaryResources.tapID = tapID
        logger.debug("Created process tap #\(tapID)")

        // Build multi-device aggregate description
        // First device is clock source, others have drift compensation for sync
        let description = buildAggregateDescription(
            outputUIDs: targetDeviceUIDs,
            tapUUID: tapDesc.uuid,
            name: "FineTune-\(app.id)"
        )

        var aggID: AudioObjectID = .unknown
        err = AudioHardwareCreateAggregateDevice(description as CFDictionary, &aggID)
        guard err == noErr else {
            cleanupPartialActivation()
            throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: [NSLocalizedDescriptionKey: "Failed to create aggregate device: \(err)"])
        }
        primaryResources.aggregateDeviceID = aggID
        CrashGuard.trackDevice(aggID)

        guard primaryResources.aggregateDeviceID.waitUntilReady(timeout: 2.0) else {
            cleanupPartialActivation()
            throw NSError(domain: "ProcessTapController", code: -1, userInfo: [NSLocalizedDescriptionKey: "Aggregate device not ready within timeout"])
        }

        logger.debug("Created aggregate device #\(self.primaryResources.aggregateDeviceID)")

        // Compute ramp coefficient from actual device sample rate.
        // Formula: coeff = 1 - exp(-1 / (sampleRate * rampTime))
        // This gives exponential smoothing where the signal reaches ~63% of target in rampTime.
        // 30ms ramp prevents audible clicks when volume changes abruptly.
        let sampleRate: Float64
        if let deviceSampleRate = try? primaryResources.aggregateDeviceID.readNominalSampleRate() {
            sampleRate = deviceSampleRate
            logger.info("Device sample rate: \(sampleRate) Hz")
        } else {
            sampleRate = 48000
            logger.warning("Failed to read sample rate, using default: \(sampleRate) Hz")
        }
        let rampTimeSeconds: Float = 0.030  // 30ms - fast enough to feel responsive, slow enough to avoid clicks
        rampCoefficient = 1 - exp(-1 / (Float(sampleRate) * rampTimeSeconds))
        logger.debug("Ramp coefficient: \(self.rampCoefficient)")

        eqProcessor = EQProcessor(sampleRate: sampleRate)

        // Create IO proc with gain processing
        err = AudioDeviceCreateIOProcIDWithBlock(&primaryResources.deviceProcID, primaryResources.aggregateDeviceID, queue) { [weak self] _, inInputData, _, outOutputData, _ in
            guard let self else {
                // Zero output to prevent garbage audio if controller is deallocated
                let outputs = UnsafeMutableAudioBufferListPointer(outOutputData)
                for buf in outputs {
                    if let data = buf.mData { memset(data, 0, Int(buf.mDataByteSize)) }
                }
                return
            }
            self.processAudio(inInputData, to: outOutputData)
        }
        guard err == noErr else {
            cleanupPartialActivation()
            throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: [NSLocalizedDescriptionKey: "Failed to create IO proc: \(err)"])
        }

        err = AudioDeviceStart(primaryResources.aggregateDeviceID, primaryResources.deviceProcID)
        guard err == noErr else {
            cleanupPartialActivation()
            throw NSError(domain: NSOSStatusErrorDomain, code: Int(err), userInfo: [NSLocalizedDescriptionKey: "Failed to start device: \(err)"])
        }

        _primaryCurrentVolume = _volume

        // Track current devices for external queries
        currentDeviceUIDs = targetDeviceUIDs

        activated = true
        logger.info("Tap activated for \(self.app.name) on \(self.targetDeviceUIDs.count) device(s)")
    }

    /// Switch to a single device (convenience for backward compatibility).
    func switchDevice(to newDeviceUID: String) async throws {
        try await updateDevices(to: [newDeviceUID])
    }

    /// Updates output devices using crossfade for seamless transition.
    /// Creates a second tap+aggregate for the new device set, crossfades, then destroys the old one.
    func updateDevices(to newDeviceUIDs: [String]) async throws {
        precondition(!newDeviceUIDs.isEmpty, "Must have at least one target device")

        guard activated else {
            targetDeviceUIDs = newDeviceUIDs
            return
        }

        guard newDeviceUIDs != currentDeviceUIDs else { return }

        let startTime = CFAbsoluteTimeGetCurrent()
        logger.info("[UPDATE] Switching \(self.app.name) to \(newDeviceUIDs.count) device(s)")

        // For now, crossfade uses the first (primary) device
        // All devices in the aggregate will be included
        let primaryDeviceUID = newDeviceUIDs[0]

        do {
            try await performCrossfadeSwitch(to: primaryDeviceUID, allDeviceUIDs: newDeviceUIDs)
        } catch {
            logger.warning("[UPDATE] Crossfade failed: \(error.localizedDescription), using fallback")
            guard primaryResources.tapDescription != nil else {
                throw CrossfadeError.noTapDescription
            }
            try await performDestructiveDeviceSwitch(to: primaryDeviceUID, allDeviceUIDs: newDeviceUIDs)
        }

        targetDeviceUIDs = newDeviceUIDs
        currentDeviceUIDs = newDeviceUIDs

        let endTime = CFAbsoluteTimeGetCurrent()
        logger.info("[UPDATE] === END === Total time: \((endTime - startTime) * 1000)ms")
    }

    /// Tears down the tap and releases all CoreAudio resources.
    /// Safe to call multiple times - subsequent calls are no-ops.
    private var _invalidating = false
    func invalidate() {
        guard activated, !_invalidating else { return }
        _invalidating = true
        defer { _invalidating = false }
        activated = false

        // Cancel any in-flight crossfade task
        crossfadeTask?.cancel()
        crossfadeTask = nil

        logger.debug("Invalidating tap for \(self.app.name)")

        crossfadeState.complete()

        // destroyAsync() captures IDs, clears instance state immediately,
        // then dispatches blocking teardown to a background queue.
        // Safe even if activate() is called again before cleanup completes.
        secondaryResources.destroyAsync()
        primaryResources.destroyAsync()

        logger.info("Tap invalidated for \(self.app.name)")
    }

    deinit {
        invalidate()
    }

    // MARK: - Crossfade Operations

    private func performCrossfadeSwitch(to primaryDeviceUID: String, allDeviceUIDs: [String]? = nil) async throws {
        let deviceUIDs = allDeviceUIDs ?? [primaryDeviceUID]

        // Re-entrant guard (ORCH-001): if already switching, tear down in-progress secondary
        if isSwitching {
            logger.warning("[CROSSFADE] Re-entrant switch detected — tearing down in-progress secondary")
            cleanupSecondaryTap()
            crossfadeState.complete()
        }
        isSwitching = true
        defer { isSwitching = false }

        logger.info("[CROSSFADE] Step 1: Reading device volumes for compensation")

        var isBluetoothDestination = false
        if let destDevice = deviceMonitor?.device(for: primaryDeviceUID) {
            let transport = destDevice.id.readTransportType()
            isBluetoothDestination = (transport == .bluetooth || transport == .bluetoothLE)
            logger.debug("[CROSSFADE] Destination device: BT=\(isBluetoothDestination)")
        }

        logger.info("[CROSSFADE] Step 2: Preparing crossfade state")

        // Enter warmingUp phase before tap creation so audio callbacks see correct state.
        // totalSamples is set inside createSecondaryTap after reading sample rate.
        crossfadeState.beginWarmup()

        logger.info("[CROSSFADE] Step 3: Creating secondary tap for \(deviceUIDs.count) device(s)")
        try createSecondaryTap(for: deviceUIDs)

        // LIFE-004/005: Ensure secondary tap is cleaned up if crossfade fails or is cancelled
        var crossfadeCompleted = false
        defer {
            if !crossfadeCompleted {
                logger.warning("[CROSSFADE] Cleaning up secondary tap after failure/cancellation")
                cleanupSecondaryTap()
                crossfadeState.complete()
            }
        }

        if isBluetoothDestination {
            logger.info("[CROSSFADE] Destination is Bluetooth - using extended warmup")
        }

        let warmupMs = isBluetoothDestination ? 300 : 50
        logger.info("[CROSSFADE] Step 4: Waiting for secondary tap warmup (\(warmupMs)ms)...")
        try await Task.sleep(for: .milliseconds(UInt64(warmupMs)))

        // Transition to crossfading phase now that warmup sleep has elapsed
        crossfadeState.beginCrossfading()
        logger.info("[CROSSFADE] Step 5: Crossfade in progress (\(CrossfadeConfig.duration * 1000)ms)")

        let timeoutMs = Int(CrossfadeConfig.duration * 1000) + (isBluetoothDestination ? 400 : 100)
        let pollIntervalMs: UInt64 = 5
        var elapsedMs: Int = 0

        while (!crossfadeState.isCrossfadeComplete || !crossfadeState.isWarmupComplete) && elapsedMs < timeoutMs {
            try await Task.sleep(for: .milliseconds(pollIntervalMs))
            elapsedMs += Int(pollIntervalMs)
        }

        // Handle timeout - force completion if progress incomplete
        let progressAtTimeout = crossfadeState.progress
        if progressAtTimeout < 1.0 {
            logger.warning("[CROSSFADE] Timeout at \(progressAtTimeout * 100)% - forcing completion")
            crossfadeState.progress = 1.0
        }

        // Verify secondary tap is valid before promotion
        guard secondaryResources.aggregateDeviceID.isValid, secondaryResources.deviceProcID != nil else {
            logger.error("[CROSSFADE] Secondary tap invalid after timeout")
            // defer will handle cleanup (cleanupSecondaryTap + crossfadeState.complete)
            throw CrossfadeError.secondaryTapFailed
        }

        try await Task.sleep(for: .milliseconds(10))

        logger.info("[CROSSFADE] Crossfade complete, promoting secondary")

        destroyPrimaryTap()
        promoteSecondaryToPrimary()

        crossfadeState.complete()
        crossfadeCompleted = true

        logger.info("[CROSSFADE] Complete")
    }

    private func createSecondaryTap(for outputUIDs: [String]) throws {
        precondition(!outputUIDs.isEmpty, "Must have at least one output device")

        let tapDesc = CATapDescription(stereoMixdownOfProcesses: [app.objectID])
        tapDesc.uuid = UUID()
        tapDesc.muteBehavior = .mutedWhenTapped
        secondaryResources.tapDescription = tapDesc

        var tapID: AudioObjectID = .unknown
        var err = AudioHardwareCreateProcessTap(tapDesc, &tapID)
        guard err == noErr else {
            throw CrossfadeError.tapCreationFailed(err)
        }
        secondaryResources.tapID = tapID
        logger.debug("[CROSSFADE] Created secondary tap #\(tapID)")

        // Build multi-device aggregate description using helper
        let description = buildAggregateDescription(
            outputUIDs: outputUIDs,
            tapUUID: tapDesc.uuid,
            name: "FineTune-\(app.id)-secondary"
        )

        var aggID: AudioObjectID = .unknown
        err = AudioHardwareCreateAggregateDevice(description as CFDictionary, &aggID)
        guard err == noErr else {
            // TapResources.destroy() handles correct teardown order + CrashGuard.untrackDevice
            secondaryResources.destroy()
            throw CrossfadeError.aggregateCreationFailed(err)
        }
        secondaryResources.aggregateDeviceID = aggID
        CrashGuard.trackDevice(aggID)

        guard secondaryResources.aggregateDeviceID.waitUntilReady(timeout: 2.0) else {
            secondaryResources.destroy()
            throw CrossfadeError.deviceNotReady
        }

        logger.debug("[CROSSFADE] Created secondary aggregate #\(self.secondaryResources.aggregateDeviceID)")

        let sampleRate: Double
        if let deviceSampleRate = try? secondaryResources.aggregateDeviceID.readNominalSampleRate() {
            sampleRate = deviceSampleRate
        } else {
            sampleRate = 48000
        }
        crossfadeState.totalSamples = CrossfadeConfig.totalSamples(at: sampleRate)

        let rampTimeSeconds: Float = 0.030
        secondaryRampCoefficient = 1 - exp(-1 / (Float(sampleRate) * rampTimeSeconds))

        _secondaryCurrentVolume = _primaryCurrentVolume

        err = AudioDeviceCreateIOProcIDWithBlock(&secondaryResources.deviceProcID, secondaryResources.aggregateDeviceID, queue) { [weak self] _, inInputData, _, outOutputData, _ in
            guard let self else {
                // Zero output to prevent garbage audio if controller is deallocated
                let outputs = UnsafeMutableAudioBufferListPointer(outOutputData)
                for buf in outputs {
                    if let data = buf.mData { memset(data, 0, Int(buf.mDataByteSize)) }
                }
                return
            }
            self.processAudioSecondary(inInputData, to: outOutputData)
        }
        guard err == noErr else {
            secondaryResources.destroy()
            throw CrossfadeError.tapCreationFailed(err)
        }

        err = AudioDeviceStart(secondaryResources.aggregateDeviceID, secondaryResources.deviceProcID)
        guard err == noErr else {
            secondaryResources.destroy()
            throw CrossfadeError.tapCreationFailed(err)
        }

        logger.debug("[CROSSFADE] Secondary tap started")
    }

    private func destroyPrimaryTap() {
        primaryResources.destroy()
    }

    /// Tears down any in-progress secondary tap (used by re-entrant crossfade guard).
    private func cleanupSecondaryTap() {
        guard secondaryResources.isActive else { return }
        secondaryResources.destroy()
    }

    private func promoteSecondaryToPrimary() {
        primaryResources = secondaryResources
        secondaryResources = TapResources()

        if let deviceSampleRate = try? primaryResources.aggregateDeviceID.readNominalSampleRate() {
            let rampTimeSeconds: Float = 0.030
            rampCoefficient = 1 - exp(-1 / (Float(deviceSampleRate) * rampTimeSeconds))
            eqProcessor?.updateSampleRate(deviceSampleRate)
        }

        _primaryCurrentVolume = _secondaryCurrentVolume
        _secondaryCurrentVolume = 0

        // CrossfadeState reset is handled by the caller (performCrossfadeSwitch calls complete())
    }

    private func performDestructiveDeviceSwitch(to primaryDeviceUID: String, allDeviceUIDs: [String]? = nil) async throws {
        let deviceUIDs = allDeviceUIDs ?? [primaryDeviceUID]
        let originalVolume = _volume

        _forceSilence = true
        OSMemoryBarrier()
        // LIFE-011: Ensure _forceSilence is always cleared, even if switch throws
        defer { _forceSilence = false; OSMemoryBarrier() }
        logger.info("[SWITCH-DESTROY] Enabled _forceSilence=true")

        try await Task.sleep(for: .milliseconds(100))

        try performDeviceSwitch(to: deviceUIDs)

        _primaryCurrentVolume = 0
        _volume = 0

        try await Task.sleep(for: .milliseconds(150))

        _forceSilence = false

        for i in 1...10 {
            _volume = originalVolume * Float(i) / 10.0
            try await Task.sleep(for: .milliseconds(20))
        }

        logger.info("[SWITCH-DESTROY] Complete")
    }

    private func performDeviceSwitch(to outputUIDs: [String]) throws {
        precondition(!outputUIDs.isEmpty, "Must have at least one output device")

        var newResources = TapResources()

        let newTapDesc = CATapDescription(stereoMixdownOfProcesses: [app.objectID])
        newTapDesc.uuid = UUID()
        newTapDesc.muteBehavior = .mutedWhenTapped
        newResources.tapDescription = newTapDesc

        var tapID: AudioObjectID = .unknown
        var err = AudioHardwareCreateProcessTap(newTapDesc, &tapID)
        guard err == noErr else {
            throw CrossfadeError.tapCreationFailed(err)
        }
        newResources.tapID = tapID

        // Build multi-device aggregate description using helper
        let description = buildAggregateDescription(
            outputUIDs: outputUIDs,
            tapUUID: newTapDesc.uuid,
            name: "FineTune-\(app.id)"
        )

        var aggID: AudioObjectID = .unknown
        err = AudioHardwareCreateAggregateDevice(description as CFDictionary, &aggID)
        guard err == noErr else {
            newResources.destroy()
            throw CrossfadeError.aggregateCreationFailed(err)
        }
        newResources.aggregateDeviceID = aggID
        CrashGuard.trackDevice(aggID)

        guard newResources.aggregateDeviceID.waitUntilReady(timeout: 2.0) else {
            newResources.destroy()
            throw CrossfadeError.deviceNotReady
        }

        err = AudioDeviceCreateIOProcIDWithBlock(&newResources.deviceProcID, newResources.aggregateDeviceID, queue) { [weak self] _, inInputData, _, outOutputData, _ in
            guard let self else {
                // Zero output to prevent garbage audio if controller is deallocated
                let outputs = UnsafeMutableAudioBufferListPointer(outOutputData)
                for buf in outputs {
                    if let data = buf.mData { memset(data, 0, Int(buf.mDataByteSize)) }
                }
                return
            }
            self.processAudio(inInputData, to: outOutputData)
        }
        guard err == noErr else {
            newResources.destroy()
            throw CrossfadeError.tapCreationFailed(err)
        }

        err = AudioDeviceStart(newResources.aggregateDeviceID, newResources.deviceProcID)
        guard err == noErr else {
            newResources.destroy()
            throw CrossfadeError.tapCreationFailed(err)
        }

        // Destroy old resources, adopt new
        primaryResources.destroy()
        primaryResources = newResources
        targetDeviceUIDs = outputUIDs
        currentDeviceUIDs = outputUIDs

        if let deviceSampleRate = try? primaryResources.aggregateDeviceID.readNominalSampleRate() {
            rampCoefficient = 1 - exp(-1 / (Float(deviceSampleRate) * 0.030))
            eqProcessor?.updateSampleRate(deviceSampleRate)
        }
    }

    private func cleanupPartialActivation() {
        primaryResources.destroy()
    }

    // MARK: - RT-Safe Audio Callbacks (DO NOT MODIFY WITHOUT RT-SAFETY REVIEW)
    // These callbacks run on CoreAudio's real-time HAL I/O thread.
    // See .claude/rules/rt-safety.md for constraints.

    /// Audio processing callback for PRIMARY tap.
    /// **RT SAFETY CONSTRAINTS - DO NOT:**
    /// - Allocate memory (malloc, Array append, String operations)
    /// - Acquire locks/mutexes
    /// - Use Objective-C messaging
    /// - Call print/logging functions
    /// - Perform file/network I/O
    private func processAudio(_ inputBufferList: UnsafePointer<AudioBufferList>, to outputBufferList: UnsafeMutablePointer<AudioBufferList>) {
        let outputBuffers = UnsafeMutableAudioBufferListPointer(outputBufferList)
        // SAFETY: Mutable cast required by UnsafeMutableAudioBufferListPointer API,
        // but we only read through this pointer. Input buffer data is owned by CoreAudio
        // and valid for callback duration.
        let inputBuffers = UnsafeMutableAudioBufferListPointer(UnsafeMutablePointer(mutating: inputBufferList))

        if _forceSilence {
            for outputBuffer in outputBuffers {
                guard let outputData = outputBuffer.mData else { continue }
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
            }
            return
        }

        // Track peak level for VU meter
        var maxPeak: Float = 0.0
        for inputBuffer in inputBuffers {
            guard let inputData = inputBuffer.mData else { continue }
            let inputSamples = inputData.assumingMemoryBound(to: Float.self)
            let sampleCount = Int(inputBuffer.mDataByteSize) / MemoryLayout<Float>.size
            for i in stride(from: 0, to: sampleCount, by: 2) {
                let absSample = abs(inputSamples[i])
                if absSample > maxPeak {
                    maxPeak = absSample
                }
            }
        }
        let rawPeak = min(maxPeak, 1.0)
        _peakLevel = _peakLevel + levelSmoothingFactor * (rawPeak - _peakLevel)

        if _isMuted {
            for outputBuffer in outputBuffers {
                guard let outputData = outputBuffer.mData else { continue }
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
            }
            return
        }

        let targetVol = _volume
        var currentVol = _primaryCurrentVolume

        // Equal-power crossfade: primary uses cosine curve (1→0), secondary uses sine curve (0→1)
        // cos²(x) + sin²(x) = 1, so total power remains constant throughout transition.
        // CrossfadeState.primaryMultiplier handles all phase logic including the race condition
        // guard (returns 0.0 when progress >= 1.0 in idle phase after crossfade completes).
        let crossfadeMultiplier = crossfadeState.primaryMultiplier

        let inputBufferCount = inputBuffers.count
        let outputBufferCount = outputBuffers.count

        // Buffer routing: Aggregate devices can have more input than output buffers.
        // Extra inputs appear at the BEGINNING of the list (e.g., device mic channels).
        // The process tap output occupies the LAST N input buffers.
        //
        // Offset formula: inputIndex = (inputCount - outputCount) + outputIndex
        //
        // Example: 4-in/2-out USB interface
        //   inputs[0..1] = device mic (skip)
        //   inputs[2..3] = tap output → map to outputs[0..1]
        //
        // If inputCount < outputCount, we map 1:1 and zero any unmatched output buffers
        // (handled by the guard below).
        for outputIndex in 0..<outputBufferCount {
            let outputBuffer = outputBuffers[outputIndex]
            guard let outputData = outputBuffer.mData else { continue }

            let inputIndex: Int
            if inputBufferCount > outputBufferCount {
                inputIndex = inputBufferCount - outputBufferCount + outputIndex
            } else {
                inputIndex = outputIndex
            }

            guard inputIndex < inputBufferCount else {
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
                continue
            }

            let inputBuffer = inputBuffers[inputIndex]
            guard let inputData = inputBuffer.mData else {
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
                continue
            }

            let inputSamples = inputData.assumingMemoryBound(to: Float.self)
            let outputSamples = outputData.assumingMemoryBound(to: Float.self)
            let sampleCount = Int(inputBuffer.mDataByteSize) / MemoryLayout<Float>.size

            // Read preamp attenuation once per buffer (RT-safe atomic Float read).
            // This reduces signal before EQ to prevent clipping when bands are boosted.
            // When EQ is disabled or crossfading, skip preamp (no EQ boost to compensate for).
            let preamp: Float = (eqProcessor != nil && !crossfadeState.isActive) ? (eqProcessor?.preampAttenuation ?? 1.0) : 1.0

            // Per-sample volume ramping prevents clicks. The exponential approach
            // (currentVol += (target - current) * coeff) gives smooth transitions.
            for i in 0..<sampleCount {
                currentVol += (targetVol - currentVol) * rampCoefficient
                let sample = inputSamples[i] * currentVol * crossfadeMultiplier * preamp
                outputSamples[i] = sample
            }

            // EQ intentionally disabled during crossfade: biquad delay buffers contain
            // state tuned to the old device's sample rate. Processing through them produces
            // incorrect frequency response. The ~50ms crossfade gap is inaudible.
            if let eqProcessor = eqProcessor, !crossfadeState.isActive {
                let channels = Int(inputBuffer.mNumberChannels)
                let frameCount = channels > 1 ? sampleCount / channels : sampleCount
                eqProcessor.process(input: outputSamples, output: outputSamples, frameCount: frameCount)
            }

            // Post-EQ soft limiting: catches any clipping from EQ boost or volume > 1.0.
            // Uses vDSP_maxmgv fast path — zero overhead when buffer is below threshold.
            SoftLimiter.processBuffer(outputSamples, sampleCount: sampleCount)
        }

        _primaryCurrentVolume = currentVol
    }

    /// Audio processing callback for SECONDARY tap during crossfade.
    private func processAudioSecondary(_ inputBufferList: UnsafePointer<AudioBufferList>, to outputBufferList: UnsafeMutablePointer<AudioBufferList>) {
        let outputBuffers = UnsafeMutableAudioBufferListPointer(outputBufferList)
        // SAFETY: Mutable cast required by UnsafeMutableAudioBufferListPointer API,
        // but we only read through this pointer. Input buffer data is owned by CoreAudio
        // and valid for callback duration.
        let inputBuffers = UnsafeMutableAudioBufferListPointer(UnsafeMutablePointer(mutating: inputBufferList))

        var maxPeak: Float = 0.0
        var totalSamplesThisBuffer: Int = 0
        for inputBuffer in inputBuffers {
            guard let inputData = inputBuffer.mData else { continue }
            let inputSamples = inputData.assumingMemoryBound(to: Float.self)
            let sampleCount = Int(inputBuffer.mDataByteSize) / MemoryLayout<Float>.size
            if totalSamplesThisBuffer == 0 {
                totalSamplesThisBuffer = sampleCount / 2
            }
            for i in stride(from: 0, to: sampleCount, by: 2) {
                let absSample = abs(inputSamples[i])
                if absSample > maxPeak {
                    maxPeak = absSample
                }
            }
        }
        let rawPeak = min(maxPeak, 1.0)
        _secondaryPeakLevel = _secondaryPeakLevel + levelSmoothingFactor * (rawPeak - _secondaryPeakLevel)

        // Update crossfade progress via state machine (handles sample counting + phase logic)
        _ = crossfadeState.updateProgress(samples: totalSamplesThisBuffer)

        if _isMuted {
            for outputBuffer in outputBuffers {
                guard let outputData = outputBuffer.mData else { continue }
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
            }
            return
        }

        let targetVol = _volume
        var currentVol = _secondaryCurrentVolume

        // CrossfadeState.secondaryMultiplier handles all phase logic:
        // .warmingUp → 0.0 (muted), .crossfading → sin(progress*π/2), .idle → 1.0
        let crossfadeMultiplier = crossfadeState.secondaryMultiplier

        let inputBufferCount = inputBuffers.count
        let outputBufferCount = outputBuffers.count

        for outputIndex in 0..<outputBufferCount {
            let outputBuffer = outputBuffers[outputIndex]
            guard let outputData = outputBuffer.mData else { continue }

            let inputIndex: Int
            if inputBufferCount > outputBufferCount {
                inputIndex = inputBufferCount - outputBufferCount + outputIndex
            } else {
                inputIndex = outputIndex
            }

            guard inputIndex < inputBufferCount else {
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
                continue
            }

            let inputBuffer = inputBuffers[inputIndex]
            guard let inputData = inputBuffer.mData else {
                memset(outputData, 0, Int(outputBuffer.mDataByteSize))
                continue
            }

            let inputSamples = inputData.assumingMemoryBound(to: Float.self)
            let outputSamples = outputData.assumingMemoryBound(to: Float.self)
            let sampleCount = Int(inputBuffer.mDataByteSize) / MemoryLayout<Float>.size

            let preamp: Float = (eqProcessor != nil && !crossfadeState.isActive) ? (eqProcessor?.preampAttenuation ?? 1.0) : 1.0

            for i in 0..<sampleCount {
                currentVol += (targetVol - currentVol) * secondaryRampCoefficient
                let sample = inputSamples[i] * currentVol * crossfadeMultiplier * preamp
                outputSamples[i] = sample
            }

            // EQ intentionally disabled during crossfade: biquad delay buffers contain
            // state tuned to the old device's sample rate. Processing through them produces
            // incorrect frequency response. The ~50ms crossfade gap is inaudible.
            if let eqProcessor = eqProcessor, !crossfadeState.isActive {
                let channels = Int(inputBuffer.mNumberChannels)
                let frameCount = channels > 1 ? sampleCount / channels : sampleCount
                eqProcessor.process(input: outputSamples, output: outputSamples, frameCount: frameCount)
            }

            // Post-EQ soft limiting: catches any clipping from EQ boost or volume > 1.0.
            // Uses vDSP_maxmgv fast path — zero overhead when buffer is below threshold.
            SoftLimiter.processBuffer(outputSamples, sampleCount: sampleCount)
        }

        _secondaryCurrentVolume = currentVol
    }
}
